<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Hello JQuery</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <style>
        .title {
            background-color: lightblue;
        }
        .hidden { display: none; }
    </style>

</head>
<body>
    <div class="title">focus and blur</div>
    <!-- sample HTML -->
    <!--focus and blur -->
    <div>
        <label id="fbLabel" for="phone">Phone</label>
        <input id="fbInput" type="text" id="phone" />
        <span id="phone-help"></span>
    </div>
  
    <div class="title">mouseenter and mouseleave</div>

    <!-- sample HTML -->
    <!--mouseenter and mouseleave -->
    <div>
        <span id="target">Basic data</span>
        <span id="target-help"></span>
    </div>

    <!--Delegation and dynamic elements-->
    <!-- sample HTML -->

    <div class="title">Delegation and dynamic elements</div>

    <button id="button1">Click</button>
    <div id="placeholder"></div>

    <button id="button2">Click</button>
    <div id="placeholder2"></div>


    <!-- Single execution 
        When you register an event handler with an object, that event handler will remain with that object until you unregister it, which you could do with a function such as off.
        However, what if you know in advance you only want the event to execute once? For instance, if you're creating a button that will submit a form, you only want the user to click the button once. 
        Wouldn't it be great if you could tell jQuery to only use the event handler one time?
        Fortunately, you can!
    -->
    <div class="title">Single execution</div>
    <button id="single">This only works once</button>
    <div id="output"></div>

    <!-- Triggering events
        Typically events are raised by the user performing the action themselves. 
        But there may be scenarios where you want to raise the event programatically. 
        For example, you may want to allow a user to click on a button to refresh data, or perform the operation on your own through code. 
        jQuery allows you to raise events through one of three methods, 
        either the registration method, such as click, or one of two trigger methods: trigger or triggerHandler.
    -->
    <div class="title">Triggering events</div>
    <button type="button" class="b" id="first">First button</button>
    <button type="button" class="b" id="Second">Second button</button>
    <button type="button" class="b" id="trigger">trigger</button>
    <button type="button" class="b" id="trigger-handler">triggerHandler</button>


    <!--Manipulating the DOM 
    As we've already seen, html and text can be used to update the page. 
    The problem with those functions, however, is those functions replace the contents of the element they're called on, rather than modifying the content. 
    You could, I suppose, keep appending text, but after a while your code will fall under its own weight.
    jQuery offers several functions to easily manipulate the DOM.
    -->
    <div class="title">Manipulating the DOM with prepend-prependTo and append-appendTo</div>
    <div id="target2">
        <div>existing content</div>
    </div>


    <div class="title">Manipulating the DOM with afer-insertAfter and before-insertBefore</div>
    <div id="target3">
        <div>existing content</div>
    </div>

    <!-- Wrapping content
    Wrapping existing content with new content
    There will be times you'll need to manipulate the DOM by surrounding existing content with a new element. 
    jQuery provides several wrapping functions to perform that type of an operation.-->
    <div class="title">Wrapping content</div>
    <div id="wrap-me">
        <div class="demo">Item one</div>
        <div class="demo">Item two</div>
    </div>

    <!-- Animations -->
    <div class="title">Animations</div>
    <button type="button" id="btn-toggle">Toggle</button>
    <div id="target4">Show or hide</div>


    <!-- Animatyins in action
    Animations in action
    In the prior demonstrations and videos, we saw how to use show, hide and toggle to easily modify the visibility of an item, 
    while also adding a little bit of animation to the UI. 
    While this is certainly a neat trick, there's a very good chance you'll want to start a UI with a section already hidden.
    -->
    
    <div class="title"> Animations in action</div>
    <form>
        <div>
            <label id="nameLabel">Name:</label>
            <input id="nameInput" type="text" />
        </div>
        <button type="button" id="show-additional-information">
            Show additional information
        </button>
        <div id="additional-information" class="hidden">
            <label id="aiLabel">Additional information:</label>
            <input id="aiInput" type="text" />
        </div>
    </form>

    <!-- -->
    <div></div>
    




    <p></p>
    <div class="title"> CodePen Related Links</div>

    <p>  </p>
    <div>
 
        <a href="https://codepen.io/GeekTrainer/pen/d95ba170fb444e4c530d3a07e6ef42ec">Event, delegation and one demonstrations</a>
    </div>
    <div>   

        <a href="https://codepen.io/GeekTrainer/pen/1afc4d560d697b40f26e48b7b24a7f4e">DOM manipulation demos</a>
    </div>
    <div>   
        <a href="https://codepen.io/GeekTrainer/pen/1ad611909eeab30a35f0ba0b0b44aa07">Wrapping functions</a>
    </div>

    
    <p>  </p>
    <p class="title"> _</p>



</body>
<footer>
    <script src="https://ajax.aspnetcdn.com/ajax/jQuery/jquery-3.3.1.js"></script>
    <script>
        function executeCommand(command){
            setTimeout(function(){
                eval(command);      
            },2000);    
        }
        function alerta() { alert('ALERTAAAAA!!'); }

    </script>
    <script>
        //$(document).ready(myFunction());
        

        //sample JavaScript
        //focus and blur 
        $('#phone')
        .focus(function() {
            // Control has focus. Display help
            $('#phone-help').text('Please enter your phone number as all digits');
        })
        .blur(function() {
            // Control lost focus. Clear help
            $('#phone-help').text('');
        });

        //sample Javascript
        //mouseenter and mouseleave and hover
        $('#target')
        .mouseenter(function() {
            $('#target-help').text('More data');
        })
        .mouseleave(function() {
            $('#target-help').text('');
        });

        //sample Javascript
        //hover
        //The hover event is logically equivalent to both the mouseenter and mouseleave events. What makes hover special is you can actually register two event handlers in one call. The first parameter hover accepts is for mouseenter, or when the hover begins, and the second parameter is for mouseout.

        $('#target')
        .hover(function() {
            // mouseenter
            $('#target-help').text('More data');
        }, function() {
            // mouseleave
            $('#target-help').text('');
        });

        //sample Javascript
        //val
        $("#phone").val("holllalalalal");

        setTimeout(function(){
            $("#phone").val("");        
        },2000);

        // write text out to the screen
        // this will be displayed as the literal
        // value
        // the text value will not be bolded

        $('#fbLabel').text('<strong>value</strong>');

        // write text out to the screen
        // this will be displayed as value
        // with the word bolded
        
        setTimeout(function(){
            $('#fbLabel').html('<strong>value</strong>');         
        },2000);

        // Change an item's color to red
        $('#target').css('color', 'red');
        $('#target').css('background-color', 'yellow');
        
        //this attr is going to replace the style attribute, not update it, so any existing styles would be lost. 
        executeCommand("$('#target').attr('style', 'color: red')");

        //on and off

        $('#target').on('click', alerta);
        $('#target').off('click', alerta);
        
        //Delegation and dynamic elements

        /*Delegating event handlers with on
        With jQuery 1.7, delegate is superseded by on. You may have noticed in the prior unit on had a selector parameter as well. 
        If you do not provide that selector, on behaves like a normal event handler registration. 
        But, if you do provide a selector, it will use delegation to register the event handlers.

        One important thing to note is the order of parameters for on and delegate. 
        With on, you list the events first and the selector second. With delegate, it's selector followed by events.
        */

        // Delegation (note the order of parameters)
        //$(document).on('click', '#button1', function() {alert('hello'); });

        // Semantically the same as above
        // (note the order of parameters)
        //$(document).delegate('#button2', 'click', function() { alert('hello'); });

        $(function() {
            // document.ready (on load)

            // register a click event handler with all button elements
            $('button[id=button1]').click(function() { alert('hello'); });

            // create a new button that it will NO react under the click event
            $('#placeholder').html('<button id=button1>New button</button>');
        });

        $(function() {
            // document.ready (on load)

            // register a click event handler with all button elements
            $('body').delegate('button[id=button2]','click',function() { alert('hello'); });

            // create a new button that it will react under the click event
            $('#placeholder2').html('<button id=button2>New button2</button>');
        });

        //Single event execution
        $(function() {
            $('#single').one('click', function() {
                $('#output').text($('#output').text()+'You clicked on the button');
            });
        });

        /* Try to replace the function above for this one 
        $(function() {
            $('#single').on('click', function() {
                $('#output').text($('#output').text()+'You clicked on the button');
            });
        });
        I check what happens 
        */
        
        /***************************************************************************************************

        //Triggering events

        /*Typically events are raised by the user performing the action themselves. But there may be scenarios where you want to raise the event programatically. 
        For example, you may want to allow a user to click on a button to refresh data, or perform the operation on your own through code. 
        jQuery allows you to raise events through one of three methods, either the registration method, such as click, or one of two trigger methods: trigger or triggerHandler.
        */
        
        $(function() {
            $('button.b').click(function() {
                // display the id of the button
                alert(this.id);
            });

            $('#trigger').click(function() {
                // Would alert every button's id
                // including the last two
                //we will expect a never ending bucle of alerts
                $('button.b').trigger('click');
            });

            // Would alert "first"
            $('#trigger-handler').click(function() {
                // Would alert "first"
                $('button.b').triggerHandler('click');
            });
        });
        
        /*************************************************************************************

        /*Manipulating the DOM

        Internal DOM manipulation
        If you wish to update the contents of an element by adding or removing elements, you can use append, appendTo, prepend and prependTo. 
        Remember that the element you target will become the container for the new element. 
        So using append will add a new element inside the target, not after the element. (There's another function for that.)

        prepend and prependTo
        prepend and prependTo add new content to the begining of the contents of a target. 
        The difference between them is the order in which the parameters and target are passed in. The lines of code below are semantically identical.
        */
        // prepend is called on the target, and accepts the new content as the parameter
        

        $('#target2').prepend('<div>New content with prepend</div>');

        // prependTo is called on the new content, and accepts the target as the parameter
        $('<div>New content prependTo</div>').prependTo('#target2');

        /*If you had the following starting HTML

        And executed either of the lines of JavaScript above, the result would be as follows.

        <div id="target">
            <div>New content</div>
            <div>existing content</div>
        </div>
        append and appendTo
        append and appendTo add new content to the end of the contents of a target. 
        The difference between them is the order in which the parameters and target are passed in. The lines of code below are semantically identical.
        */

        // append is called on the target, and accepts the new content as the parameter

        $('#target2').append('<div>New content with append</div>');

        // appendTo is called on the new content, and accepts the target as the parameter
        $('<div>New content with appentTo</div>').appendTo('#target2');
        /*If you had the following starting HTML

        <div id="target">
            <div>existing content</div>
        </div>
        And executed either of the lines of JavaScript above, the result would be as follows.

        <div id="target">
            <div>existing content</div>
            <div>New content</div>
        </div>
        */
        //************************************************************************************* 

        //External DOM manipulation
        /*
        External DOM manipulation
        Functions such as prepend add new content inside of the target, using the target as a container for the new content. 
        If you wish to add new content before or after an existing element, jQuery provides after, insertAfter, before, and insertBefore.
        */
        
        /*
        after and insertAfter
        after and insertAfter both add new content after the target, on the same level of the hierarchy, rather than inside the target. 
        The difference between the two functions is the order of parameters and target.

        // after is called on the target, and accepts the new content as a parameter
        */
        $('#target3').after('New content using after');

        // insertAfter is called on the new content, and accepts the target as a parameter
        $('New content using insertAfter').insertAfter('#target3'); // it seems it isn't run
        /*If you had the following HTML as the starting point:

        <div id="target">
            <div>existing content</div>
        </div>
        //... calling either of the lines of JavaScript above would produce the following result:

        <div id="target">
            <div>existing content</div>
        </div>
        <div>New content</div>
        before and insertBefore
        before and insertBefore both add new content after the target, on the same level of the hierarchy, rather than inside the target. 
        The difference between the two functions is the order of parameters and target.

        // before is called on the target, and accepts the new content as a parameter*/
        $('#target3').before('New content using before');

        // insertBefore is called on the new content, and accepts the target as a parameter
        $("New content using insertBefore").insertBefore("#target3"); // it seems it isn't run
        /*If you had the following HTML as the starting point:

        <div id="target">
            <div>existing content</div>
        </div>
        ... calling either of the lines of JavaScript above would produce the following result:

        <div>New content</div>
        <div id="target">
            <div>existing content</div>
        </div>
        */

        //************************************************************************************* 

        /* wrapping functions
        
        For the wrap and wrapAll demonstrations below, we'll be using this HTML as the starting point:

        <div id="wrap-me">
            <div class="demo">Item one</div>
            <div class="demo">Item two</div>
        </div>
        wrap
        The wrap function wraps each item with the element passed into the function. As a result, if you called:
        */
        //$('#wrap-me').wrap('<section></section>');
        /*the result would be:

        <section>
            <div id="wrap-me">
                <div class="demo">Item one</div>
                <div class="demo">Item two</div>
            </div>
        </section>
        Where things get a little more interesting is if you used a selector that returned multiple items. Imagine the following JavaScript:
        */
        //$('.demo').wrap('<section></section>');
        /*The result would be:

        <div id="wrap-me">
            <section>
                <div class="demo">Item one</div>
            </section>
            <section>
                <div class="demo">Item two</div>
            </section>
        </div>
        Notice that wrap will wrap each element returned by the selector with the new element.

        wrapAll
        wrapAll behaves differently. Rather than wrapping each returned element, wrapAll wraps all returned content with one new element. 
        As a result, the JavaScript
        */
        //$('.demo').wrapAll('<section></section>');
        /*would result in

        <div id="wrap-me">
            <section>
                <div class="demo">Item one</div>
                <div class="demo">Item two</div>
            </section>
        </div>
        wrapInner
        wrapInner is different from both wrap and wrapAll in that wrapInner operates on the children of the target, rather than on the target itself. 
        If you started with the following HTML...
        
        <div id="">
            <div>Item one</div>
            <div>Item two</div>
        </div>
        ...and executed the JavaScript below...
        */
        $('.demo').wrapInner('<section></section>');
        /*...the result would be:

        <div id="">
            <section>
                <div>Item one</div>
                <div>Item two</div>
            </section>
        </div>
        */
        //************************************************************************************* 
        
        /*
        Introducing Animations
        Up until now, whenever we've manipulated the DOM the results have just appeared. 
        While this is just fine, it can sometimes be a bit jarring to the user. 
        It would certainly be nice if we could have just a little animation, to either make our page look more professional, 
        or to draw the user's attention to the new or updated content.

        hide, show and toggle
        jQuery offers many animations. 
        The first two are hide and show. As you might suspect, hide causes something to disappear from the screen, while show causes something to appear. 
        toggle, on the other hand, determines the current status of the item in question and changes it. 
        So if the item was currently hidden, toggle would call show, and if the item was visible, toggle would call hide.

        Behind the scenes, jQuery controls visibility by using the display property in CSS. When you hide and item, 
        jQuery will store the current value of display (such as inline or block) and then set the display to none. 
        When you call show, jQuery resets the display CSS property back to the value it had stored before.

        hide, show and toggle all take several parameters, including a set of options that allow you to control things like "easing", 
        which is how the animation is going to take place. 
        Most commonly the only parameter you will provide is the duration you wish the animation to take place over, in milleseconds.

        <div id="target">Show or hide</div>
        <button type="button" id="btn-toggle">Toggle</button>
        */
        $(function() {
            $('#btn-toggle').click(function() {
                // animation will take one second
                $('#target4').toggle(1000);
            });
        });

        /*One final note about this, and all animations. 
        Animations in jQuery return a promise object, which can be used to run code after an animation completes. We'll discuss promises in Module 3.
        */


        //**************************************************************************************
        
        /*
        Animations in action
        In the prior demonstrations and videos, we saw how to use show, hide and toggle to easily modify the visibility of an item, 
        while also adding a little bit of animation to the UI. 
        While this is certainly a neat trick, there's a very good chance you'll want to start a UI with a section already hidden.

        Imagine the following scenario:

        <form>
            <div>
                <label>Name:</label>
                <input type="text" />
            </div>
            <div>
                <label>Additional information:</label>
                <input type="text" />
            </div>
        </form>
        In the above form, we want to prompt the user for their name, and additional information. But what happens if that additional information is optional? 
        It would be nice to provide some form of a button, checkbox, or otherwise, to enable the user to display the additional information section, 
        rather than always displaying it.
        Or, imagine if you were building a page where you had additional details, maybe a user agreement, 
        that many people will ignore. Displaying that on the page takes up unnecessary real estate.
        In both of those scenarios, it'd be great if we could hide the item, 
        and only if the user indicates they want to see the extra data should we show it to them.
        We can accomplish this by starting with the following HTML, updated from before:

        <style>
            .hidden { display: none; }
        </style>
        <form>
            <div>
                <label>Name:</label>
                <input type="text" />
            </div>
            <button type="button" id="show-additional-information">
                Show additional information
            </button>
            <div id="additional-information" class="hidden">
                <label>Additional information:</label>
                <input type="text" />
            </div>
        </form>
        ...and then added the following script
        */
        $(function() {
            $('#show-additional-information').click(function() {
                $('#additional-information').show(750);
            }); 
        });
        /*You'll notice that we're setting the div element with additional-information as its ID to display:none to start. 
        The display property is what show will modify. We're then setting up the click event handler to call show, which will then cause the item to display.
        */

    </script>

</footer>
</html>